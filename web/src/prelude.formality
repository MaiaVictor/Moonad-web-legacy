main = App.example

// Identity

the
: {A : Type} {u : A} A
= [A] [u] u

// A self-referential type

Self
: {T : (Self T)} Type
= [T] {self : (T self)} Type

// The empty, uninhabited type

Empty
: (Self Empty)
= [self]
  {-Prop : (Self Empty)}
  (Prop self)

// The unit type

Unit
: (Self Unit)
= [self]
  {-Prop : (Self Unit)}
  {new   : (Prop Unit.new)}
  (Prop self)

Unit.new
: (Unit Unit.new)
= [-Prop] [new] new

// The booleans true and false

Bool
: (Self Bool)
= [self]
  {-Prop : (Self Bool)}
  {true  : (Prop Bool.true)}
  {false : (Prop Bool.false)}
  (Prop self)

Bool.true
: (Bool Bool.true)
= [-Prop] [true] [false] true

Bool.false
: (Bool Bool.false)
= [-Prop] [true] [false] false

Bool.induct
: {self  : (Bool self)}
  {-Prop : (Self Bool)}
  {true  : (Prop Bool.true)}
  {false : (Prop Bool.false)}
  (Prop self)
= [self] [-Prop] [true] [false]
  (self -Prop true false)

Bool.equals
: {x : (Bool x)}
  {y : (Bool y)}
  (Bool (Bool.equals x y))
= [x] [y] [-Prop] [true] [false]
  (x -[x] (Prop (Bool.equals x y))
    (y -[y](Prop (Bool.equals Bool.true y))
      true
      false)
    (y -[y](Prop (Bool.equals Bool.false y))
      false
      true))

Bool.not
: {self : (Bool self)} (Bool (Bool.not self))
= [self]
  (self
    -[self] (Bool (Bool.not self))
    Bool.false
    Bool.true)

Bool.not2
: {self : (Bool self)} (Bool (Bool.not self))
= [self] [-Prop] [T] [F]
  (self -[self] (Prop (Bool.not self)) F T)

// Natural numbers

Nat
: (Self Nat)
= [self]
  {-Prop : (Self Nat)}
  {succ  : {pred : (Nat pred)} (Prop (Nat.succ pred))}
  {zero  : (Prop Nat.zero)}
  (Prop self)

Nat.succ
: {pred : (Nat pred)} (Nat (Nat.succ pred))
= [pred] [-Prop] [succ] [zero]
  (succ pred)

Nat.zero
: (Nat Nat.zero)
= [-Prop] [succ] [zero] zero

Nat.0 : (Nat Nat.0) = Nat.zero
Nat.1 : (Nat Nat.1) = (Nat.succ Nat.0)
Nat.2 : (Nat Nat.2) = (Nat.succ Nat.1)
Nat.3 : (Nat Nat.3) = (Nat.succ Nat.2)
Nat.4 : (Nat Nat.4) = (Nat.succ Nat.3)
Nat.5 : (Nat Nat.5) = (Nat.succ Nat.4)
Nat.6 : (Nat Nat.6) = (Nat.succ Nat.5)
Nat.7 : (Nat Nat.7) = (Nat.succ Nat.6)
Nat.8 : (Nat Nat.8) = (Nat.succ Nat.7)
Nat.9 : (Nat Nat.9) = (Nat.succ Nat.8)

Nat.id
: {a : (Nat a)} (Nat (Nat.id a))
= [a] [-Prop] [succ] [zero]
  (a
    -[a] (Prop (Nat.id a))
    [pred] (succ (Nat.id pred))
    zero)

Nat.copy
: {a : (Nat a)} (Nat (Nat.copy a))
= [a]
  (a
    -[a] (Nat (Nat.copy a))
    [pred] (Nat.succ (Nat.copy pred))
    Nat.zero)

Nat.double
: {n : (Nat n)} (Nat (Nat.double n))
= [n]
  (n
    -[n] (Nat (Nat.double n))
    [pred] (Nat.succ (Nat.succ (Nat.double pred)))
    Nat.zero)

Nat.add
: {a : (Nat a)} {b : (Nat b)} (Nat (Nat.add a b))
= [a] [b]
  (a
    -[a] (Nat (Nat.add a b))
    [a] (Nat.succ (Nat.add a b))
    b)

Nat.add_n_zero
: {n : (Nat n)} (Eq Nat (Nat.add n Nat.zero) n (Nat.add_n_zero n))
= [n]
  (n
    -[self] (Eq Nat (Nat.add self Nat.zero) self (Nat.add_n_zero self))
    [pred] (Eq.cong Nat Nat (Nat.add pred Nat.zero) pred (Nat.add_n_zero pred) Nat.succ)
    (Eq.refl Nat Nat.zero))

Nat.add_n_succ_m
: {n : (Nat n)} {m : (Nat m)} (Eq Nat (Nat.add n (Nat.succ m)) (Nat.succ (Nat.add n m)) (Nat.add_n_succ_m n m))
= [N] [M]
  (N
    -[self] (Eq Nat (Nat.add self (Nat.succ M)) (Nat.succ (Nat.add self M)) (Nat.add_n_succ_m self M))
    [pred] (Eq.cong Nat Nat (Nat.add pred (Nat.succ M)) (Nat.succ (Nat.add pred M)) (Nat.add_n_succ_m pred M) Nat.succ)
    (Eq.refl Nat (Nat.succ M)))

Nat.add_comm
: {n : (Nat n)} {m : (Nat m)} (Eq Nat (Nat.add n m) (Nat.add m n) (Nat.add_comm n m))
= [n : (Nat n)]
  (n
    -[self] {m : (Nat m)} (Eq Nat (Nat.add self m) (Nat.add m self) (Nat.add_comm self m))
    [pred] [m]
      (Eq.subst Nat
        (Nat.add m pred) (Nat.add pred m) (Eq.sym Nat (Nat.add pred m) (Nat.add m pred) (Nat.add_comm pred m))
        [x : (Nat x)] (Eq Nat (Nat.succ x) (Nat.add m (Nat.succ pred)))
        (Eq.sym Nat (Nat.add m (Nat.succ pred)) (Nat.succ (Nat.add m pred)) (Nat.add_n_succ_m m pred)))
    [m] (Eq.sym Nat (Nat.add m Nat.zero) m (Nat.add_n_zero m)))

// Natural numbers (Church)

Cat
: (Self Cat)
= [self]
  {-P : (Self P)}
  {s  : {x : (P x)} (P (s x))}
  {z  : (P z)}
  (P (self -P s z))

Cat.succ
: {n : (Cat n)} (Cat (Cat.succ n))
= [n] [-P] [s] [z]
  (s (n -P s z))

Cat.zero
: (Cat Cat.zero)
= [-P] [s] [z]
  z

Cat.0 : (Cat Cat.0) = Cat.zero
Cat.1 : (Cat Cat.1) = (Cat.succ Cat.0)
Cat.2 : (Cat Cat.2) = (Cat.succ Cat.1)
Cat.3 : (Cat Cat.3) = (Cat.succ Cat.2)
Cat.4 : (Cat Cat.4) = (Cat.succ Cat.3)
Cat.5 : (Cat Cat.5) = (Cat.succ Cat.4)
Cat.6 : (Cat Cat.6) = (Cat.succ Cat.5)
Cat.7 : (Cat Cat.7) = (Cat.succ Cat.6)
Cat.8 : (Cat Cat.8) = (Cat.succ Cat.7)
Cat.9 : (Cat Cat.9) = (Cat.succ Cat.8)

Cat.add
: {n : (Cat n)} {m : (Cat m)} (Cat (Cat.add n m))
= [n] [m] [-P] [s] [z]
  (n -P s (m -P s z))

Cat.mul
: {n : (Cat n)} {m : (Cat m)} (Cat (Cat.mul n m))
= [n] [m] [-P] [s] [z]
  (n -P (m -P s) z)

Cat.example
: (Eq Cat Cat.zero Cat.zero (Eq.refl Cat Cat.zero))
= (Eq.refl Cat Cat.zero)

Cat.is_even
: {n : (Cat n)} (Bool (Cat.is_even n))
= [n]
  (n
    -[n : (Bool n)] (Bool n)
    [n : (Bool n)] (Bool.not n)
    Bool.true)

// Natural numbers (Parigot)

Rat
: (Self Rat)
= [self]
  {-Prop : {self : (Rat self)} {fold : (Prop self fold)} Type}
  {succ  : {pred : (Rat pred)} {fold : (Prop pred fold)} (Prop (Rat.succ pred) (succ pred fold))}
  {zero  : (Prop Rat.zero zero)}
  (Prop self (self -Prop succ zero))

Rat.succ
: {pred : (Rat pred)} (Rat (Rat.succ pred))
= [pred] [-Prop] [succ] [zero]
  (succ pred (pred -Prop succ zero))

Rat.zero
: (Rat Rat.zero)
= [-Prop] [succ] [zero] zero

Rat.0 : (Rat Rat.0) = Rat.zero
Rat.1 : (Rat Rat.1) = (Rat.succ Rat.0)
Rat.2 : (Rat Rat.2) = (Rat.succ Rat.1)
Rat.3 : (Rat Rat.3) = (Rat.succ Rat.2)
Rat.4 : (Rat Rat.4) = (Rat.succ Rat.3)
Rat.5 : (Rat Rat.5) = (Rat.succ Rat.4)
Rat.6 : (Rat Rat.6) = (Rat.succ Rat.5)
Rat.7 : (Rat Rat.7) = (Rat.succ Rat.6)
Rat.8 : (Rat Rat.8) = (Rat.succ Rat.7)
Rat.9 : (Rat Rat.9) = (Rat.succ Rat.8)

Rat.to_cat
: {n : (Rat n)} (Cat (Rat.to_cat n))
= [n] (n
  -[self : (Rat self)] [fold : (Cat fold)] (Cat fold)
  [pred : (Rat pred)] [fold : (Cat fold)] (Cat.succ fold)
  Cat.zero)

Rat.id
: {n : (Rat n)} (Rat (Rat.id n))
= [n] (n
  -[self : (Rat self)] [fold : (Rat fold)] (Rat fold)
  [pred : (Rat pred)] [fold : (Rat fold)] (Rat.succ (Rat.succ (Rat.succ fold)))
  Rat.zero)

Rat.add_n_zero
: {n : (Rat n)} (Eq Rat (Rat.add n Rat.zero) n (Rat.add_n_zero n))
= [n]
  let motive [self : (Rat self)] [fold : (Eq Rat (Rat.add self Rat.zero) self fold)]
    (Eq Rat (Rat.add self Rat.zero) self fold)
  let case_succ [pred : (Rat pred)] [fold : (Eq Rat (Rat.add pred Rat.zero) pred fold)]
    (Eq.cong Rat Rat (Rat.add pred Rat.zero) pred (Rat.add_n_zero pred) Rat.succ)
  let case_zero
    (Eq.refl Rat Rat.zero)
  (n -motive case_succ case_zero)

Rat.add
: {n : (Rat n)} {m : (Rat m)} (Rat (Rat.add n m))
= [n] [m] (n
  -[n : (Rat n)] [r : (Rat r)] (Rat r)
  [n : (Rat n)] [r : (Rat r)] (Rat.succ r)
  m)

// Binary

Bin
: (Self Bin)
= [self]
  {-Prop : (Self Bin)}
  {O     : {pred : (Bin pred)} (Prop (Bin.O pred))}
  {I     : {pred : (Bin pred)} (Prop (Bin.I pred))}
  {E     : (Prop Bin.E)}
  (Prop self)

Bin.O
: {pred : (Bin pred)}
  (Bin (Bin.O pred))
= [pred] [-Prop] [O] [I] [E]
  (O pred)

Bin.I
: {pred : (Bin pred)}
  (Bin (Bin.I pred))
= [pred] [-Prop] [O] [I] [E]
  (I pred)

Bin.E
: (Bin Bin.E)
= [-Prop] [O] [I] [E]
  E

Bin.inc
: {x : (Bin x)}
  (Bin (Bin.inc x))
= [xs] (xs -[self : (Bin self)] (Bin (Bin.inc self))
  [pred] (Bin.I pred)
  [pred] (Bin.O (Bin.inc pred))
  Bin.E)

Bin.equals
: {x : (Bin x)}
  {y : (Bin y)}
  (Bool (Bin.equals x y))
= [x] (x -[x] {y : (Bin y)} (Bool (Bin.equals x y))
  [xp] [y] (y -[y](Bool (Bin.equals (Bin.O xp) y))
    [yp] (Bin.equals xp yp)
    [yp] Bool.false
    Bool.false)
  [xp] [y] (y -[y](Bool (Bin.equals (Bin.I xp) y))
    [yp] Bool.false
    [yp] (Bin.equals xp yp)
    Bool.false)
  [y] (y -[y](Bool (Bin.equals Bin.E y))
    [yp] Bool.false
    [yp] Bool.false
    Bool.true))

// Equality

Eq
: {T    : (Self T)}
  {a    : (T a)}
  {b    : (T b)}
  {self : (Eq T a b self)}
  Type
= [T] [a] [b] [self]
  {Prop : {b : (T b)} {self : (Eq T a b self)} Type}
  {refl : (Prop a (Eq.refl T a))}
  (Prop b self)

Eq.refl
: {T : (Self T)}
  {a : (T a)}
  (Eq T a a (Eq.refl T a))
= [T] [a] [Prop] [refl]
  refl

Eq.sym
: {T : {self : (T self)} Type}
  {a : (T a)}
  {b : (T b)}
  {e : (Eq T a b e)}
  (Eq T b a (Eq.sym T a b e))
= [T] [a] [b] [e]
  (e [b] [self] (Eq T b a (Eq.sym T a b self))
    (Eq.refl T a))

Eq.cong
: {A : {self : (A self)} Type}
  {B : {self : (B self)} Type}
  {a : (A a)}
  {b : (A b)}
  {e : (Eq A a b e)}
  {f : {a : (A a)} (B (f a))}
  (Eq B (f a) (f b) (Eq.cong A B a b e f))
= [A] [B] [a] [b] [e] [f]
  (e [b] [self] (Eq B (f a) (f b) (Eq.cong A B a b self f))
    (Eq.refl B (f a)))

Eq.subst
: {T : (Self T)}
  {a : (T a)}
  {b : (T b)}
  {e : (Eq T a b e)}
  {P : {a : (T a)} (Self (P a))}
  {x : (P a x)}
  (P b (Eq.subst T a b e P x))
= [T] [a] [b] [e] [P] [x]
  (e [b] [self] (P b (Eq.subst T a b self P x)) x)


// Sigma

Sigma
: {A : (Self A)}
  {B : {x : (A x)} (Self (B x))}
  (Self (Sigma A B))
= [A] [B] [self]
  {-Prop : {self : (Sigma A B self)} Type}
  {new   : {a : (A a)} {b : (B a b)} (Prop (Sigma.new A B a b))}
  (Prop self)

Sigma.new
: {A : (Self A)}
  {B : {x : (A x)} (Self (B x))}
  {a : (A a)}
  {b : (B a b)}
  (Sigma A B (Sigma.new A B a b))
= [A] [B] [a] [b] [-Prop] [new]
  (new a b)

Sigma.fst
: {A : (Self A)}
  {B : {x : (A x)} (Self (B x))}
  {sigma : (Sigma A B sigma)}
  (A (Sigma.fst A B sigma))
= [A] [B] [sigma]
  (sigma
    -[self] (A (Sigma.fst A B self))
    [a] [b] a)

Sigma.snd
: {A : (Self A)}
  {B : {x : (A x)} (Self (B x))}
  {sigma : (Sigma A B sigma)}
  (B (Sigma.fst A B sigma) (Sigma.snd A B sigma))
= [A] [B] [sigma]
  (sigma
    -[self] (B (Sigma.fst A B self) (Sigma.snd A B self))
    [a] [b] b)

Sigma.example
= (Sigma.new Nat [x : (Nat x)](Eq Nat x x) Nat.3 (Eq.refl Nat Nat.3))

// Lists

List
: {A : (Self A)}
  (Self (List A))
= [A] [self]
  {-Prop : (Self (List A))}
  {cons  : {head : (A head)} {tail : (List A tail)} (Prop (List.cons A head tail))}
  {nil   : (Prop (List.nil A))}
  (Prop self)

List.cons
: {A    : (Self A)}
  {head : (A head)}
  {tail : (List A tail)}
  (List A (List.cons A head tail))
= [A] [head] [tail] [-Prop] [cons] [nil]
  (cons head tail)

List.nil
: {A : (Self A)}
  (List A (List.nil A))
= [A] [-Prop] [cons] [nil]
  nil

List.length
: {A : (Self A)}
  {l : (List A l)}
  (Nat (List.length A l))
= [A] [l]
  let motive [self]
    (Nat (List.length A self))
  let case_cons [head] [tail]
    (Nat.succ (List.length A tail))
  let case_nil
    Nat.zero
  (l -motive case_cons case_nil) 

List.map
: {A : (Self A)}
  {f : {x : (A x)} (A (f x))}
  {l : (List A l)}
  (List A (List.map A f l))
= [A] [f] [l]
  let motive [self]
    (List A (List.map A f self))
  let case_cons [head] [tail]
    (List.cons A (f head) (List.map A f tail))
  let case_nil
    (List.nil A)
  (l -motive case_cons case_nil)

// Byte

Byte
: (Self Byte)
= [self]
  {-Prop : (Self Byte)}
  {new :
    {x0 : (Bool x0)}
    {x1 : (Bool x1)}
    {x2 : (Bool x2)}
    {x3 : (Bool x3)}
    {x4 : (Bool x4)}
    {x5 : (Bool x5)}
    {x6 : (Bool x6)}
    {x7 : (Bool x7)}
    (Prop (Byte.new x0 x1 x2 x3 x4 x5 x6 x7))}
  (Prop self)

Byte.new
: {x0 : (Bool x0)}
  {x1 : (Bool x1)}
  {x2 : (Bool x2)}
  {x3 : (Bool x3)}
  {x4 : (Bool x4)}
  {x5 : (Bool x5)}
  {x6 : (Bool x6)}
  {x7 : (Bool x7)}
  (Byte (Byte.new x0 x1 x2 x3 x4 x5 x6 x7))
= [x0] [x1] [x2] [x3] [x4] [x5] [x6] [x7] [-Prop] [new]
  (new x0 x1 x2 x3 x4 x5 x6 x7)

Byte.0
: (Byte Byte.0)
= let 0 Bool.false
  let 1 Bool.true
  (Byte.new 0 0 1 1 0 0 0 0)

Byte.1
: (Byte Byte.1)
= let 0 Bool.false
  let 1 Bool.true
  (Byte.new 0 0 1 1 0 0 0 1)

Bin.to_bytes
: {b : (Bin b)} (List Byte (Bin.to_bytes b))
= [b] (b -[b](List Byte (Bin.to_bytes b))
  [bs](List.cons Byte Byte.0 (Bin.to_bytes bs))
  [bs](List.cons Byte Byte.1 (Bin.to_bytes bs))
  (List.nil Byte))

// App

App
: (Self App)
= [self]
  {-Prop : (Self App)}
  {new :
    {init : (Bin init)}
    {next : {event : (Bin event)} {state : (Bin state)} (Bin (next event state))}
    {draw : {state : (Bin state)} (Bin (draw state))}
    (Prop (App.new init next draw))}
  (Prop self)

App.new
: {init : (Bin init)}
  {next : {event : (Bin event)} {state : (Bin state)} (Bin (next event state))}
  {draw : {state : (Bin state)} (Bin (draw state))}
  (App (App.new init next draw))
= [init] [next] [draw] [-Prop] [new]
  (new init next draw)

App.init
: {app : (App app)}
  (Bin (App.init app))
= [app]
  let motive [self]
    (Bin (App.init self))
  let case_new [init] [next] [draw]
    init
  (app -motive case_new)

App.next
: {app : (App app)}
  {event : (Bin event)}
  {state : (Bin state)}
  (Bin (App.next app event state))
= [app]
  let motive [self]
    {event : (Bin event)}
    {state : (Bin state)}
    (Bin (App.next self event state))
  let case_new [init] [next] [draw]
    next
  (app -motive case_new)

App.draw
: {app : (App app)}
  {state : (Bin state)}
  (Bin (App.draw app state))
= [app]
  let motive [self]
    {state : (Bin state)} (Bin (App.draw self state))
  let case_new [init] [next] [draw]
    draw
  (app -motive case_new)
  
App.example
: (App App.example)
= let init (Bin.O (Bin.O (Bin.O (Bin.O Bin.E))))
  let next [event : (Bin event)] [state : (Bin state)] (Bin.inc state)
  let draw [state : (Bin state)] state
  (App.new init next draw)
